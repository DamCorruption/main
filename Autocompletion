<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autocompletion model</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #121212; color: #e0e0e0; display: flex;
            justify-content: center; align-items: center; min-height: 100vh; margin: 0; padding: 20px 0;
        }
        .container {
            width: 80%; max-width: 700px; background-color: #1e1e1e; border-radius: 8px;
            padding: 20px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        h1 {
            color: #bb86fc; text-align: center; border-bottom: 2px solid #373737; padding-bottom: 10px;
        }
        .chat-window {
            height: 250px; border: 1px solid #373737; background-color: #2c2c2c;
            padding: 10px; margin-bottom: 15px; overflow-y: auto; border-radius: 4px;
        }
        .chat-message { margin-bottom: 8px; word-wrap: break-word; }
        .user-message { color: #03dac6; }
        .system-message { color: #cf6679; font-style: italic;}
        .chatbox-container { display: flex; }
        #chat-input {
            flex-grow: 1; padding: 10px; border: 1px solid #373737; background-color: #2c2c2c;
            color: #e0e0e0; border-radius: 4px; font-size: 1em;
        }
        .button-group { margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap; }
        .button {
            padding: 10px 15px; border: none; font-weight: bold; cursor: pointer;
            border-radius: 4px; transition: background-color 0.2s;
        }
        #train-button { background-color: #bb86fc; color: #121212; }
        #train-button:hover { background-color: #a067e8; }
        #save-button, #import-label { background-color: #03dac6; color: #121212; }
        #save-button:hover, #import-label:hover { background-color: #01b8a1; }
        .button:disabled { background-color: #373737; cursor: not-allowed; color: #888; }
        #import-input { display: none; }
        .status-box {
            margin-top: 15px; padding: 10px; background-color: #252525;
            border-left: 4px solid #03dac6; min-height: 40px;
        }
        #prediction-container { font-weight: bold; color: #f0e68c; }
        .tab-hint { font-size: 0.8em; color: #888; }
        textarea {
            width: 100%; box-sizing: border-box; height: 150px; background-color: #2c2c2c;
            color: #e0e0e0; border: 1px solid #373737; margin-top: 10px; font-family: monospace;
        }
        .blinking-cursor { animation: blink 1s step-end infinite; }
        @keyframes blink { from, to { opacity: 1; } 50% { opacity: 0; } }
        #progress-container {
            width: 100%; background-color: #373737; border-radius: 4px; margin-top: 10px; display: none;
        }
        #progress-bar {
            width: 0%; height: 10px; background-color: #03dac6; border-radius: 4px;
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>SNN Autocomplete v5 (Save/Import)</h1>
        <p>Training Data:</p>
        <textarea id="training-data">
Hello, how are you? I am fine, thank you.
How are you doing today? I am doing great!
What is your name? My name is a simple model. I do not have a real name.
What can you do? I can predict the next word in a sentence.
That is very cool. Thank you, I try my best.
The weather is nice today. Yes, the weather is sunny and warm.
I like sunny weather. I like rainy weather too, it is very peaceful.
What are you learning about? I am learning about human language.
Language is very complex... yes, it is very interesting. I find it fascinating.
Do you have any friends? You are my friend. Everyone who talks to me is a friend.
That is nice to hear. I am happy to help in any way I can.
What time is it? I do not have a clock, so I cannot tell the time.
Can you tell me a joke? Why did the scarecrow win an award?
Because he was outstanding in his field.
That is a funny joke! I am glad you think so.
Good morning. Good afternoon. Good evening. Good night.
See you later! Goodbye for now. I hope we talk again soon.
Hey, how is it going? It is going well, thanks for asking.
How was your day? My day was very productive.
What did you do today? I learned a lot of new words and phrases.
That sounds like a good day. It was a very good day indeed.
The sky is blue, the grass is green, and the sun is bright.
The moon is in the sky at night.
I want to ask a question. Please, go ahead and ask. I will do my best to answer.
What is your favorite color? I do not see colors, but I like the idea of blue.
What is the meaning of life? That is a very deep question. I think it is about learning and growing.
Do you like music? I cannot hear music, but I process text that describes it.
My favorite food is electricity. It is very energizing!
I was created by a developer using code.
This is a demonstration of a Spiking Neural Network.
The network learns from the text provided here.
You can save the trained model to a file. You can also import a saved model.
This prevents you from having to train me every single time.
Thank you for interacting with me!
        </textarea>
        <div class="button-group">
            <button id="train-button" class="button">Train Model</button>
            <button id="save-button" class="button" disabled>Save Model</button>
            <label for="import-input" id="import-label" class="button">Import Model</label>
            <input type="file" id="import-input" accept=".json">
        </div>
        <div id="progress-container"><div id="progress-bar"></div></div>

        <div class="status-box">
            Status: <span id="status">Idle. Press 'Train Model' or 'Import Model'.</span><br>
            Prediction: <span id="prediction-container"><span id="prediction-text"></span><span class="blinking-cursor">|</span></span> <span class="tab-hint">(Press Tab to complete)</span>
        </div>

        <div class="chat-window" id="chat-window"></div>
        <div class="chatbox-container">
            <input type="text" id="chat-input" placeholder="Train or import a model to begin..." disabled>
        </div>
    </div>

    <script>
        const ui = {
            chatInput: document.getElementById('chat-input'),
            chatWindow: document.getElementById('chat-window'),
            trainButton: document.getElementById('train-button'),
            saveButton: document.getElementById('save-button'),
            importInput: document.getElementById('import-input'),
            status: document.getElementById('status'),
            predictionText: document.getElementById('prediction-text'),
            trainingData: document.getElementById('training-data'),
            progressContainer: document.getElementById('progress-container'),
            progressBar: document.getElementById('progress-bar'),
        };

        const SNN_PARAMS = { NUM_NEURONS: 120, SPARSITY: 0.1, THRESHOLD: 1.0, DECAY: 0.95, REFRACTORY_PERIOD: 5, INPUT_STRENGTH: 2.0, SIM_TIME_PER_WORD: 10, LEARNING_RATE: 0.001, EPOCHS: 50, TYPEWRITER_SPEED_MS: 80 };

        let model = {}, typewriter = {};
        function resetModel() {
            model = {
                vocabulary: [], wordToIndex: {}, neurons: [], reservoirWeights: [],
                inputWeights: {}, readoutWeights: {}, isTrained: false,
                successorMap: new Map(), originalCaseMap: new Map(),
                stateCache: new Map(),
            };
            typewriter = { animationId: null, fullPrediction: "" };
        }
        resetModel(); // Initialize on load

        // --- Event Listeners ---
        ui.trainButton.addEventListener('click', trainModel);
        ui.saveButton.addEventListener('click', saveModel);
        ui.importInput.addEventListener('change', importModel);
        ui.chatInput.addEventListener('input', handleTyping);
        ui.chatInput.addEventListener('keydown', handleKeyDown);

        // --- Tokenizer & Initialization ---
        function tokenize(text) { return text.match(/[\w']+|[.,!?;:"]|[\n]/g) || []; }

        function initializeNetwork(vocabulary, numNeurons) {
            model.vocabulary = vocabulary;
            model.wordToIndex = vocabulary.reduce((acc, word, i) => ({ ...acc, [word]: i }), {});
            
            model.neurons = Array(numNeurons).fill(0).map(() => ({ p: 0, r: 0, s: false }));
            model.reservoirWeights = Array(numNeurons).fill(0).map(() => Array(numNeurons).fill(0).map(() => Math.random() < SNN_PARAMS.SPARSITY ? Math.random() - 0.5 : 0));
            
            model.inputWeights = {};
            vocabulary.forEach(word => {
                model.inputWeights[word] = Array(numNeurons).fill(0).map(() => Math.random() < 0.1 ? SNN_PARAMS.INPUT_STRENGTH : 0);
            });
        }

        function runSimulationStep(inputCurrents) { const N = SNN_PARAMS.NUM_NEURONS; const incomingPotentials = Array(N).fill(0); for (let i = 0; i < N; i++) { for (let j = 0; j < N; j++) { if (model.neurons[j].s) incomingPotentials[i] += model.reservoirWeights[j][i]; } } for (let i = 0; i < N; i++) { const neuron = model.neurons[i]; neuron.s = false; if (neuron.r > 0) { neuron.p = 0; neuron.r--; } else { neuron.p = neuron.p * SNN_PARAMS.DECAY + inputCurrents[i] + incomingPotentials[i]; } if (neuron.p > SNN_PARAMS.THRESHOLD) { neuron.p = 0; neuron.r = SNN_PARAMS.REFRACTORY_PERIOD; neuron.s = true; } } }
        function processSequence(words) { const cacheKey = words.join(' '); if (model.stateCache.has(cacheKey)) { return model.stateCache.get(cacheKey); } model.neurons.forEach(n => { n.p = 0; n.r = 0; n.s = false; }); const spikeCounts = Array(SNN_PARAMS.NUM_NEURONS).fill(0); words.forEach(word => { if (!model.wordToIndex.hasOwnProperty(word)) return; const inputCurrents = model.inputWeights[word]; for (let t = 0; t < SNN_PARAMS.SIM_TIME_PER_WORD; t++) { runSimulationStep(t === 0 ? inputCurrents : Array(SNN_PARAMS.NUM_NEURONS).fill(0)); for (let i = 0; i < SNN_PARAMS.NUM_NEURONS; i++) { if (model.neurons[i].s) spikeCounts[i]++; } } }); model.stateCache.set(cacheKey, spikeCounts); return spikeCounts; }

        async function trainModel() {
            setTrainingState(true);
            const trainingText = ui.trainingData.value;
            const allTokens = tokenize(trainingText);
            
            model.successorMap.clear(); model.originalCaseMap.clear();
            for (let i = 0; i < allTokens.length - 1; i++) { const currentToken = allTokens[i], nextToken = allTokens[i+1], lowerToken = currentToken.toLowerCase(); if (!model.originalCaseMap.has(lowerToken)) { model.originalCaseMap.set(lowerToken, new Set()); } model.originalCaseMap.get(lowerToken).add(currentToken); if (!/[\w']/.test(nextToken)) { if (!model.successorMap.has(lowerToken)) { model.successorMap.set(lowerToken, new Map()); } const counts = model.successorMap.get(lowerToken); counts.set(nextToken, (counts.get(nextToken) || 0) + 1); } }
            
            const uniqueWords = [...new Set(allTokens.map(t => t.toLowerCase()).filter(t => /[\w']/.test(t)))];
            initializeNetwork(uniqueWords, SNN_PARAMS.NUM_NEURONS);
            model.readoutWeights = uniqueWords.reduce((acc, word) => ({ ...acc, [word]: Array(SNN_PARAMS.NUM_NEURONS).fill(0) }), {});

            const sentences = trainingText.split('\n').filter(s => s.trim() !== '');
            const totalSteps = sentences.length * SNN_PARAMS.EPOCHS;
            let completedSteps = 0;

            for (let epoch = 0; epoch < SNN_PARAMS.EPOCHS; epoch++) {
                for (const sentence of sentences) {
                    const tokens = tokenize(sentence).map(t => t.toLowerCase());
                    for (let i = 1; i < tokens.length; i++) {
                        const currentToken = tokens[i];
                        if (!model.wordToIndex.hasOwnProperty(currentToken)) continue;
                        const context = tokens.slice(0, i).filter(t => model.wordToIndex.hasOwnProperty(t));
                        if (context.length === 0) continue;
                        const reservoirState = processSequence(context);
                        model.vocabulary.forEach(word => {
                            const predictionScore = reservoirState.reduce((sum, spike, j) => sum + spike * model.readoutWeights[word][j], 0);
                            const target = (word === currentToken) ? 1.0 : 0.0; const error = target - predictionScore;
                            if (Math.abs(error) > 0.001) { for (let j = 0; j < SNN_PARAMS.NUM_NEURONS; j++) { if (reservoirState[j] > 0) { model.readoutWeights[word][j] += SNN_PARAMS.LEARNING_RATE * error * reservoirState[j]; } } }
                        });
                    }
                }
                completedSteps += sentences.length;
                ui.progressBar.style.width = `${(completedSteps / totalSteps) * 100}%`;
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            trainingFinished();
        }

        function saveModel() {
            if (!model.isTrained) { alert("Please train a model before saving."); return; }
            const modelData = {
                readoutWeights: model.readoutWeights,
                vocabulary: model.vocabulary,
                successorMap: Array.from(model.successorMap.entries()).map(([key, value]) => [key, Array.from(value.entries())]),
                originalCaseMap: Array.from(model.originalCaseMap.entries()).map(([key, value]) => [key, Array.from(value)]),
            };
            const blob = new Blob([JSON.stringify(modelData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'snn_model.json';
            a.click(); URL.revokeObjectURL(url);
        }

        function importModel(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const modelData = JSON.parse(e.target.result);
                    resetModel();
                    
                    initializeNetwork(modelData.vocabulary, SNN_PARAMS.NUM_NEURONS);
                    model.readoutWeights = modelData.readoutWeights;
                    model.successorMap = new Map(modelData.successorMap.map(([key, value]) => [key, new Map(value)]));
                    model.originalCaseMap = new Map(modelData.originalCaseMap.map(([key, value]) => [key, new Set(value)]));

                    trainingFinished();
                    ui.status.textContent = 'Model successfully imported!';
                    addMessage("Model loaded from file. Ready to go!", "system-message");
                } catch (error) {
                    console.error("Failed to import model:", error);
                    alert("Error: The selected file is not a valid model file.");
                }
            };
            reader.readAsText(file);
            ui.importInput.value = '';
        }

        function predictNextWord(words) { let bestWord = '', maxScore = -Infinity; model.vocabulary.forEach(word => { const score = processSequence(words).reduce((sum, spike, i) => sum + spike * model.readoutWeights[word][i], 0); if (score > maxScore) { maxScore = score; bestWord = word; } }); let punctuation = ''; if (model.successorMap.has(bestWord)) { const p = [...model.successorMap.get(bestWord).entries()]; if(p.length > 0) { p.sort((a,b) => b[1] - a[1]); punctuation = p[0][0]; }} return { word: bestWord, punctuation }; }
        function postProcessPrediction(word, punctuation, lastToken) { if (!word) return ""; if (word === 'i') return 'I' + punctuation; const sentenceEnders = ['.', '!', '?']; if (!lastToken || sentenceEnders.includes(lastToken)) { const casings = model.originalCaseMap.get(word); const capitalized = [...casings].find(c => c[0] === c[0].toUpperCase()); return (capitalized || word) + punctuation; } return word + punctuation; }
        function handleTyping() { stopPredictionAnimation(); const text = ui.chatInput.value; const tokens = tokenize(text); const words = tokens.map(t => t.toLowerCase()).filter(t => model.wordToIndex.hasOwnProperty(t)); if (words.length === 0) { typewriter.fullPrediction = ""; ui.predictionText.textContent = ""; return; } const { word, punctuation } = predictNextWord(words); const lastToken = tokens[tokens.length - 1]; const finalPrediction = postProcessPrediction(word, punctuation, lastToken); if (finalPrediction) { typewriter.fullPrediction = finalPrediction; startPredictionAnimation(typewriter.fullPrediction); } else { typewriter.fullPrediction = ""; ui.predictionText.textContent = "..."; } }
        function handleKeyDown(e) { if (e.key === 'Tab') { e.preventDefault(); acceptPrediction(); } else if (e.key === 'Enter' && ui.chatInput.value.trim() !== '') { addMessage(ui.chatInput.value.trim(), 'user-message'); ui.chatInput.value = ''; stopPredictionAnimation(); ui.predictionText.textContent = ''; typewriter.fullPrediction = ''; } }
        function startPredictionAnimation(text) { let charIndex = 0; ui.predictionText.textContent = ''; typewriter.animationId = setInterval(() => { if (charIndex < text.length) { ui.predictionText.textContent += text[charIndex++]; } else { stopPredictionAnimation(); } }, SNN_PARAMS.TYPEWRITER_SPEED_MS); }
        function stopPredictionAnimation() { clearInterval(typewriter.animationId); typewriter.animationId = null; }
        function acceptPrediction() { stopPredictionAnimation(); if (typewriter.fullPrediction) { const endsWithSpace = ui.chatInput.value.endsWith(' '); if (ui.chatInput.value.length > 0 && !endsWithSpace) { ui.chatInput.value += ' '; } ui.chatInput.value += typewriter.fullPrediction; handleTyping(); } }
        function addMessage(text, className) { const msgDiv = document.createElement('div'); msgDiv.classList.add('chat-message', className); msgDiv.textContent = `> ${text}`; ui.chatWindow.appendChild(msgDiv); ui.chatWindow.scrollTop = ui.chatWindow.scrollHeight; }
        function setTrainingState(isTraining) {
            ui.trainButton.disabled = isTraining;
            ui.chatInput.disabled = isTraining;
            ui.saveButton.disabled = true; // Always disable during training, enable on finish
            ui.progressContainer.style.display = isTraining ? 'block' : 'none';
            ui.progressBar.style.width = '0%';
            if (isTraining) {
                ui.status.textContent = 'Starting training...';
                stopPredictionAnimation();
            }
        }
        function trainingFinished() {
            model.isTrained = true;
            setTrainingState(false);
            ui.saveButton.disabled = false;
            ui.chatInput.disabled = false;
            ui.status.textContent = 'Training complete. Ready to type.';
            ui.chatInput.focus();
            addMessage("Model trained and ready!", "system-message");
        }
    </script>
</body>
</html>
